# 第二章 选择排序

## 2.1 内存的工作原理

内存用于存储数据，当我们需要在内存中存储多项数据时，有两种基本的存储方式——数组和链表。但它们并非都适用于所有情形，因此需要了解它们的差别。

## 2.2 数组和链表

### 数组

数组存储数据，要求所有数据在内存中的存储位置都是紧邻的，即整个数组需要一段连续的内存空间。

数据存储数据，执行查询操作效率很高，但执行元素的增删操作时，由于涉及到数据长度的变化，需要重新分配新的长度的连续内存空间，并进行数据的复制，因而效率较低。

### 链表

链表存储数据，各个元素数据在内存中可以分布在不同的位置，即可以利用内存中碎片化的空间进行存储。

链表存储数据，由于每次查询一个元素都需要从链表开头执行遍历，因而执行查询操作相对较慢，而执行元素的增删操作时，都是直接在原链表上特定位置上做有限修改，因而效率较高。

### 数组和链表的操作时间复杂度对比

|操作类型|数组|链表|
|------------|-----|------|
|查询|O(1)|O(n)|
|增加|O(n)|O(1)|
|删除|O(n)|O(1)|

**备注**：

    1. 这里的时间复杂度都是指最糟情况下的时间复杂度；
    
    2. 链表的增删操作的复杂度和链表的具体实现细节有关，上表中链表的增删时间复杂度，是针对只提供链表头部节点引用，且在链表头部执行增删操作而言的，如果是对这种只提供了头部节点引用的链表执行尾部的增删操作，那么时间复杂度将是O(n)。

## 2.3 选择排序

**描述**：

对包含n（n>1）个元素的列表执行选择排序（以正向排序为例），需要执行n-1次列表遍历：

+ 第1轮遍历：从列表当前的第1个元素开始，遍历找出其中最小的元素的索引，将该索引位置的元素与第1个位置的元素进行交换；
+ 第2轮遍历：从列表当前的第2个元素开始，遍历找出后续部分中最小的元素的索引，将该索引位置的元素与第2个位置的元素进行交换；
+ 第3轮遍历：从列表当前的第3个元素开始，遍历找出后续部分中最小的元素的索引，将该索引位置的元素与第3个位置的元素进行交换；
+ 第i轮遍历：从列表当前的第i个元素开始，遍历找出后续部分中最小的元素的索引，将该索引位置的元素与第i个位置的元素进行交换；
+ 第n-1轮遍历：从列表当前的第n-1个元素开始，遍历找出后续部分中最小的元素的索引，将该索引位置的元素与第n-1个位置的元素进行交换；

每轮遍历结束，会执行一次元素位置交换。选择排序最差、最好、平均情况下的时间复杂度分别为O(n^2)、O(n^2)、O(n^2)，空间复杂度为O(1)

## 2.4 小结

+ 计算机内存犹如一大堆抽屉。
+ 需要存储多个元素时，可使用数组或链表。
+ 数组的元素都在一起。
+ 链表的元素是分开的，其中每个元素都存储了下一个元素的地址。
+ 数组的读取速度很快。
+ 链表的插入和删除速度很快。
+ 在同一个数组中，所有元素的类型都必须相同。
