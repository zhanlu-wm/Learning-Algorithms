# 第五章 散列表

## 5.1 散列函数

散列函数是这样一种函数，无论你给它什么数据，它都返回给你一个数字。用专业术语来表达，我们说散列函数`将输入映射到数字`。

散列函数必须满足一些要求：

+ 它必须保证一致性。同一个输入数据，不论散列函数执行多少次，都必须返回同一个数字；
+ 它能够将不同的输入尽可能映射到不同的数字。理想情况下，它能够将每个不同的输入映射到不同的数字。

下面举例说明，假设我们有一份商品价格表，它由商品名称和商品价格组成，我们能否利用散列函数来实现商品价格的快速查找呢？

1. 首先，我们使用一个数组来存储商品价格数据；
2. 然后，我们使用一个散列函数将商品名称映射到该商品的价格在数组中的索引上；
3. 执行查询时，只要我们使用散列函数根据商品名称算得该商品的价格在数组中的索引，即可在数组中立即查找到该商品的价格数据，而且查找的时间为常数时间O(1)。

这里我们就利用数组和散列函数创建了一种称为散列表（Hash table）的数据结构。与数组和链表不同，散列表是一种包含额外逻辑的数据结构，数组和链表都是被直接映射到内存，但散列表更复杂，它使用散列函数包含的额外逻辑来确定元素的存储位置。

之前我们讨论数组和链表时知道，在数组中我们可以立即获得指定位置的元素，而散列表也是使用数组来存储数据，因此散列表中获取元素的速度与数组一样快。

## 5.2 应用案例

散列表用途广泛，下面介绍几个案例。

### 将散列表用于查找

理想情况下，在散列表中查找一个给定元素的时间都是常数O(1).

### 防止重复

由于散列表的元素查询是常数时间，因而我们在向散列表中存入新元素之前，可以快速查找确认散列表中是否已经存在该元素，从而帮助我们以较低的成本避免重复。数组或链表则不行，要确认一个元素在它们中是否已存在需要遍历整个数组或链表，随着元素数量的增加，查找是否已存在某个元素的成本将越发高昂。

### 将散列表用作缓存

缓存是一种常见的加速方式，所有大型网站都会使用缓存，而缓存的数据则存储在散列表中。为了加快网站的访问速度，我们可以将一些经常被访问的网页缓存在散列表中，并使用网页的URL映射到相应的网页数据上。用户通过一个URL访问网站页面时，会首先检查散列表中是否存储了该页面，如果已存在，则直接返回缓存的该页面内容，否则，才会让服务器做一些另外的处理，并将处理生成的数据存储到缓存中，再返回它，下次再有人访问该URL时，可以从缓存中直接返回对应的页面数据，而不用再让服务器处理了。

## 5.3 冲突

前面我们针对散列表的讨论，隐含了这样一个`理想的假定：散列函数总是能将不同的输入（键）映射到数据的不同位置。` 实际上，几乎不可能编写出这样的散列函数，当出现散列函数将不同的键映射到数据中相同的位置时，我们称之为`冲突`。

冲突很糟糕，必须要避免，处理冲突的方式有很多，最简单的办法如下：如果两个键被映射到了同一个位置，就在这个位置上存储一个链表。

但是，这种处理方式也可能存在问题，如果大部分(甚至所有)的键都被映射到同一个位置，那么在这个位置上将会有一个很长的链表，查找时由于会有很多键映射到这个位置上，这将导致每次查找时大概率会出现遍历这个长链表的情况，根据我们之前讨论的在链表上随机查找元素的时间复杂度可以知道，这将严重拖慢散列表的查找速度。

这里的经验教训有两个：

+ 散列函数很重要。上述的散列函数将大部分(甚至所有)的键都映射到同一个位置，而最理想的情况是，散列函数将键均匀地映射到散列表的不同位置。
+ 如果散列表存储的链表很长，散列表的速度将急剧下降。然而，如果使用的散列函数很好 ，这些链表就不会很长。

## 5.4 性能

散列表的性能如下：

|操作类型|平均情况|最糟情况|
|-----------|------------|------------|
|查找|O(1)|O(n)|
|插入|O(1)|O(n)|
|删除|O(1)|O(n)|

平均情况下，散列表上执行各种操作的时间都为O(1)。O(1)被称为常量时间，常量时间意味着不管散列表有多大，所需的时间都相同。在数组上根据索引值查找元素所需的时间也是常量时间。
最糟情况下，散列表所有操作的运行时间都是O(n)——线性时间。

散列表与数组和链表的性能对比如下：

|操作类型|散列表(平均情况)|散列表(最糟情况)|数组|链表|
|-----------|-----------------------|----------------------|-----|------|
|查找|O(1)|O(n)|O(1)|O(n)|
|插入|O(1)|O(n)|O(n)|O(1)|
|删除|O(1)|O(n)|O(n)|O(1)|

在平均情况下，散列表的查找（获取给定索引处的值）速度与数组一样快，而插入和删除速度与链表一样快，因此它兼具两者的优点！但在最糟情况下，散列表的各种操作的速度都很慢。因此，在使用散列表时，避开最糟情况至关重要。为此，需要避免冲突。而要避免冲突，需要有：

+ 较低的填装因子；
+ 良好的散列函数。

### 装填因子（负载因子）

散列表是装填因子很容易计算：

    装填因子 = 散列表存储的元素个数 / 散列表可用的位置总数

显然，装填因子大于1时，意味着存储到散列表的元素数量，大于散列表可用的位置总数，这时不可能使得每个元素都有自己单独的位置。通常，实现散列表时，都会为其设定一个装填因子的阈值，在向散列表不断添加元素的过程中，一旦检测到散列表当前的装填因子达到阈值，就需要在散列表中添加新的位置，这被称为调整长度（扩容）。

散列表扩容时，通常是创建一个新的数组，其长度相比原数组长度增加一倍，接下来使用散列函数将所有元素插入到这个新的数组中。扩容后，散列表装填因子会下降到一个较低的水平，装填因子越低，发生冲突的可能性就越小，散列表性能就越高。一条不错的经验是，保证散列表的装填因子在0.7附近。

散列表扩容时开销很大，我们不希望频繁出现扩容操作，因而在散列表实现中，通常允许我们根据实际应用场景为其指定一个初始容量。总体来说，即使把散列表扩容的开销考虑进去，散列表上各操作的效率依然非常高。

### 良好的散列函数

良好的散列函数让数组中的值呈均匀分布，糟糕的散列函数让值扎堆，导致大量的冲突。散列函数的结果必须是均匀分布的，这很重要，它们的映射范围必须尽可能大，最糟糕的散列函数莫过于将所有输入都映射到散列表的同一个位置。

## 5.5 小结

+ 可以结合散列函数和数组来实现散列表。
+ 冲突很糟糕，你应使用可以最大限度减少冲突的散列函数。
+ 散列表的查找、插入和删除速度都非常快。
+ 散列表适合用于仿真映射关系。
+ 一旦填装因子超过0.7，就该调整散列表的长度。
+ 散列表可用于缓存数据（例如，在Web服务器上）。
+ 散列表非常适合用于防止重复。
  