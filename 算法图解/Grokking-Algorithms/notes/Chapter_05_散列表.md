# 第五章 散列表

## 5.1 散列函数

散列函数是这样一种函数，无论你给它什么数据，它都返回给你一个数字。用专业术语来表达，我们说散列函数`将输入映射到数字`。

散列函数必须满足一些要求：

+ 它必须保证一致性。同一个输入数据，不论散列函数执行多少次，都必须返回同一个数字；
+ 它能够将不同的输入尽可能映射到不同的数字。理想情况下，它能够将每个不同的输入映射到不同的数字。

下面举例说明，假设我们有一份商品价格表，它由商品名称和商品价格组成，我们能否利用散列函数来实现商品价格的快速查找呢？

1. 首先，我们使用一个数组来存储商品价格数据；
2. 然后，我们使用一个散列函数将商品名称映射到该商品的价格在数组中的索引上；
3. 执行查询时，只要我们使用散列函数根据商品名称算得该商品的价格在数组中的索引，即可在数组中立即查找到该商品的价格数据，而且查找的时间为常数时间O(1)。

这里我们就利用数组和散列函数创建了一种称为散列表（Hash table）的数据结构。与数组和链表不同，散列表是一种包含额外逻辑的数据结构，数组和链表都是被直接映射到内存，但散列表更复杂，它使用散列函数包含的额外逻辑来确定元素的存储位置。

之前我们讨论数组和链表时知道，在数组中我们可以立即获得指定位置的元素，而散列表也是使用数组来存储数据，因此散列表中获取元素的速度与数组一样快。

## 5.2 应用案例

散列表用途广泛，下面介绍几个案例。

### 将散列表用于查找

理想情况下，在散列表中查找一个给定元素的时间都是常数O(1).

### 防止重复

由于散列表的元素查询是常数时间，因而我们在向散列表中存入新元素之前，可以快速查找确认散列表中是否已经存在该元素，从而帮助我们以较低的成本避免重复。数组或链表则不行，要确认一个元素在它们中是否已存在需要遍历整个数组或链表，随着元素数量的增加，查找是否已存在某个元素的成本将越发高昂。

### 将散列表用作缓存

缓存是一种常见的加速方式，所有大型网站都会使用缓存，而缓存的数据则存储在散列表中。为了加快网站的访问速度，我们可以将一些经常被访问的网页缓存在散列表中，并使用网页的URL映射到相应的网页数据上。用户通过一个URL访问网站页面时，会首先检查散列表中是否存储了该页面，如果已存在，则直接返回缓存的该页面内容，否则，才会让服务器做一些另外的处理，并将处理生成的数据存储到缓存中，再返回它，下次再有人访问该URL时，可以从缓存中直接返回对应的页面数据，而不用再让服务器处理了。

## 5.3 冲突

前面我们针对散列表的讨论，隐含了这样一个`理想的假定：散列函数总是能将不同的输入（键）映射到数据的不同位置。` 实际上，几乎不可能编写出这样的散列函数，当出现散列函数将不同的键映射到数据中相同的位置时，我们称之为`冲突`。

冲突很糟糕，必须要避免，处理冲突的方式有很多，最简单的办法如下：如果两个键被映射到了同一个位置，就在这个位置上存储一个链表。

但是，这种处理方式也可能存在问题，如果大部分(甚至所有)的键都被映射到同一个位置，那么在这个位置上将会有一个很长的链表，查找时由于会有很多键映射到这个位置上，这将导致每次查找时大概率会出现遍历这个长链表的情况，根据我们之前讨论的在链表上随机查找元素的时间复杂度可以知道，这将严重拖慢散列表的查找速度。

这里的经验教训有两个：

+ 散列函数很重要。上述的散列函数将大部分(甚至所有)的键都映射到同一个位置，而最理想的情况是，散列函数将键均匀地映射到散列表的不同位置。
+ 如果散列表存储的链表很长，散列表的速度将急剧下降。然而，如果使用的散列函数很好 ，这些链表就不会很长。

## 5.4 性能

散列表的性能如下：

|操作类型|平均情况|最糟情况|
|-----------|------------|------------|
|查找|O(1)|O(n)|
|插入|O(1)|O(n)|
|删除|O(1)|O(n)|

平均情况下，散列表上执行各种操作的时间都为O(1)。O(1)被称为常量时间，常量时间意味着不管散列表有多大，所需的时间都相同。在数组上根据索引值查找元素所需的时间也是常量时间。
最糟情况下，散列表所有操作的运行时间都是O(n)——线性时间。

散列表与数组和链表的性能对比如下：

|操作类型|散列表(平均情况)|散列表(最糟情况)|数组|链表|
|-----------|-----------------------|----------------------|-----|------|
|查找|O(1)|O(n)|O(1)|O(n)|
|插入|O(1)|O(n)|O(n)|O(1)|
|删除|O(1)|O(n)|O(n)|O(1)|

在平均情况下，散列表的查找（获取给定索引处的值）速度与数组一样快，而插入和删除速度与链表一样快，因此它兼具两者的优点！但在最糟情况下，散列表的各种操作的速度都很慢。因此，在使用散列表时，避开最糟情况至关重要。为此，需要避免冲突。而要避免冲突，需要有：

+ 较低的填装因子；
+ 良好的散列函数。

### 装填因子

散列表是装填因子很容易计算：

    装填因子 = 散列表的元素个数 / 底层数组容量
